## 오늘의 회고

<details>
<summary>렌더링 방식(OpenGL1)</summary>
<div markdown="1">

- OpenGL버전별 코드 실행시 주의사항
    - 이전 버전의 렌더링을 테스트할 때에는, 아래 네 줄 코드를 반드시 지우고 진행할 것
    
    ```cpp
    // 윈도우는 생성되지만, 도형이 그려지지 않음
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    // 윈도우 생성 자체가 되지 않음
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);
    ```
    
- glBegin/glEnd
    - 각 점의 좌표값과 색을 매 프레임마다 CPU에서 GPU로 넘겨주는 방식
        - 현재 기준으로는 비효율적인 방식
    - cull을 사용할 경우 우리를 향하지 않는 면은 그리지 않으므로 순서에 신경을 써야한다
        - 점 순서가 반시계 방향으로 돌아가는 게 우리를 향하는 삼각형
        - cull이 궁금하다면 [Face culling](https://heinleinsgame.tistory.com/27)
    
    ```cpp
    // {{렌더링 루프 내부}}
    glBegin(GL_TRIANGLES);
    glColor3f(1f, 0f, 0f);
    glVertex3f(0, 0.5f, 0f);
    glColor3f(0f, 1f, 0f);
    glVertex3f(-0.5f, -0.5f, 0f);
    glColor3f(0f, 0f, 1f);
    glVertex3f(0.5f, -0.5f, 0f);
    glEnd();
    ```
    
    - glVertex, glColor를 매번 불러줘야 한다
- glDrawArray
    - 각 점의 좌표값/색에 대한 정보를 배열로 한 번에 보낸다.
    - 장점: glVertex, glColor의 호출 회수를 줄인다
    - 개선점: 여전히 매 프레임마다 CPU의 데이터가 GPU로 넘어가야 한다
    
    ```cpp
    // GL_VERTEX_ARRAY 와 GL_COLOR_ARRAY 활성화
    // 점과 색상 데이터를 넘겨줄 예정임을 미리 알림
    glEnableClientState(GL_VERTEX_ARRAY);
    glEnableClientState(GL_COLOR_ARRAY);
    
    // 점과 색상 데이터의 실제 위치를 포인터로 알려준다
    // vertices와 colors는 배열의 이름
    glVertexPointer(3, GL_FLOAT, 0, vertices);
    glColorPointer(3, GL_FLOAT, 0, colors);
    
    // {{렌더링 루프 내부}}
    // 데이터를 기반으로 그려냄
    glDrawArrays(GL_TRIANGLES, 0, vertices.length/3);
    ```

</div>
</details>


---
- 핵심 목표
    - 홍정모 그래픽스 강의 완강
        - C/C++/3D수학/자료구조는 필요한 순간이 나오면 다시 살펴보자
    - 여태까지 해왔던 프로젝트 회고 남기기: 디자인 패턴, 렌더링 루프에 초점을 맞추자
- 생각할 거리
    - 어떤 기술 스택에 초점을 맞출 것인가? -> OpenGL

## 공부/정리할 내용
- git: 업스트림에 대하여
